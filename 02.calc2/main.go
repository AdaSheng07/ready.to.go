package main

import "fmt"

func main() {

	/* 计算机的原码、反码与补码
	1. 原码：
	   计算机对数字的二进制定点表示法；
	   十进制转换为二进制： 除 2 后从末尾取余；
	   最高位为符号位：正数该位为 0，负数该位为 1。
	2. 反码：
	   正数的反码和原码相同；负数是符号位为1,其它位是原码取反。
	3. 补码：
	   正数的补码和原码，反码相同；
	   负数是符号位为1，其它位是原码取反，末位加1（或者说负数的补码是其绝对值反码末位加1）； */

	// 位运算符：按二进制位进行与^、或|、异或^、左移<<、右移>>操作
	var g, h, i int = 100, 31, -20
	fmt.Printf("[100]原= %b\n", g)
	fmt.Printf("[31]原 = %b\n", h)
	fmt.Printf("[-20]原 = %b\n", i)
	// [100]原 = 0110 0100
	// [31]原 = 0001 1111
	fmt.Println("100 & 31 = ", g&h)  // 位与：[0000 0100]b = [4]d
	fmt.Println("100 | 31 = ", g|h)  // 位或：[0111 1111]b = [127]d
	fmt.Println("100 ^ 31 = ", g^h)  // 位异或：[0111 1011]b = [123]d
	fmt.Println("100 << 1 = ", g<<1) // 位左移：[1100 1000]b = [200]d 相当于翻倍
	fmt.Println("31 >> 1 = ", h>>1)  // 位右移：[0000 1111]b = [15]d 相当于减半

	// 位运算只要有负数参与，就要用补码进行运算，如果运算结果符号位为1，求补码才是答案，如果运算结果符号位为0，那么答案就是运算结果
	// 负数右移时，保证符号位为1，连带符号位右移后在末尾加1
	// [-20]原 = 1001 0100
	// [-20]反 = 1110 1011
	// [-20]补 = 1110 1100
	// [100]原 = 0110 0100
	fmt.Println("-20 & 100 =", g&i) // 位与：[0110 0100]b = [100]d
	fmt.Println("-20 | 100 =", g|i) // 位或：[1110 1100]补 = [1001 0100]b = [-20]d
	fmt.Println("-20 ^ 100 =", g^i) // 位异或: [1000 1000]补 = [1111 1000]b = [-120]d
	fmt.Println("-20 << 1 =", i<<1) // 位左移：[1101 1000]补 = [1010 1000]b = [-40]d 相当于翻倍
	fmt.Println("-20 >> 1 =", i>>1) // 位右移：[1111 0111]补 = [1000 1001]b = [-5]d 相当于减半

	// 异或^位运算的应用：在一组数字中找出唯一一个不成对的数
	arr := [...]int{1, 4, 5, 7, 6, 5, 4, 6, 1}
	result := -1 // 初始化result
	for i = 0; i < len(arr); i++ {
		if result == -1 {
			result = arr[0]
		} else {
			result = result ^ arr[i]
		}
	}
	fmt.Println("result:", result)

}
